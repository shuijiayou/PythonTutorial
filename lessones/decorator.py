#!/usr/bin/env python3
# -*- coding: utf-8 -*-
def printStr(str):
    print("====",str.__name__,"函数输出：====")

# 装饰器讲义
# http://www.jb51.net/article/99585.htm
def outer(func):
    def inner():
        print("认证成功！")
        result = func()
        print("日志添加成功")
        return result
    return inner
@outer
def f1():
 print("业务部门1数据接口......")

# 运用我们在第一部分介绍的知识来分析一下上面这段代码：

# 1. 程序开始运行，从上往下编译，读到def outer(func):的时候，发现这是个
# “一等公民”->函数，于是把函数体加载到内存里，然后过。
# 2. 读到@outer的时候，程序被@这个语法糖吸引住了，知道这是个装饰器，按规矩
# 要立即执行的，于是程序开始运行@后面那个名字outer所定义的函数。（相信
# 没有人会愚蠢的将@outer写到别的位置，它只能放在被装饰的函数的上方最近
# 处，不要空行。）
# 3. 程序返回到outer函数，开始执行装饰器的语法规则，这部分规则是定死的，是
# python的“法律”，不要问为什么。规则是：被装饰的函数的名字会被当作参数传
# 递给装饰函数。装饰函数执行它自己内部的代码后，会将它的返回值赋值给被装饰
# 的函数。


# 这里面需要注意的是：

#1.  @outer和@outer()有区别，没有括号时，outer函数依然会被执行，这和传统
# 的用括号才能调用函数不同，需要特别注意！那么有括号呢？那是装饰器的高级用法
# 了，以后会介绍。
# 2. 是f1这个函数名（而不是f1()这样被调用后）当做参数传递给装饰函数outer，
# 也就是：func = f1，@outer等于outer(f1),实际上传递了f1的函数体，而不是执
# 行f1后的返回值。
# 3. outer函数return的是inner这个函数名，而不是inner()这样被调用后的返回值。
# 如果你对第一部分函数的基础知识有清晰的了解，那么上面的内容你应该很容易理解。

# 　4. 程序开始执行outer函数内部的内容，一开始它又碰到了一个函数，很绕是吧？当然，
# 你可以在 inner函数前后安排点别的代码，但它们不是重点，而且有点小麻烦，下面会解释。
# inner函数定义块被程序观察到后不会立刻执行，而是读入内存中（这是潜规则）。

# 　5. 再往下，碰到return inner，返回值是个函数名，并且这个函数名会被赋值给f1这
# 个被装饰的函数，也就是f1 = inner。根据前面的知识，我们知道，此时f1函数被新的函数
# inner覆盖了（实际上是f1这个函数名更改成指向inner这个函数名指向的函数体内存地址，
# f1不再指向它原来的函数体的内存地址），再往后调用f1的时候将执行inner函数内的代码，
# 而不是先前的函数体。那么先前的函数体去哪了？还记得我们将f1当做参数传递给func这个
# 形参么？func这个变量保存了老的函数在内存中的地址，通过它就可以执行 老的函数体，你
# 能在inner函数里看到result = func（）这句代码，它就是这么干的！

# 　6.接下来，还没有结束。当业务部门，依然通过f1()的方式调用f1函数时，执行的就不再
# 是老的f1函数的代码，而是inner函数的代码。在本例中，它首先会打印个“认证成功”的提
# 示，很显然你可以换成任意的代码，这只是个示例；然后，它会执行func函数并将返回值赋
# 值个变量result，这个func函数就是老的f1函数；接着，它又打印了“日志保存”的提示，这
# 也只是个示例，可以换成任何你想要的；最后返回result这个变量。我们在业务部门的代码上
# 可以用 r = f1()的方式接受result的值。

# 　7.以上流程走完后，你应该看出来了，在没有对业务部门的代码和接口调用方式做任何修改
# 的同时，也没有对基础平台部原有的代码做内部修改，仅仅是添加了一个装饰函数，就实现了
# 我们的需求，在函数调用前先认证，调用后写入日志。这就是装饰器的最大作用。

# 　问题：那么为什么我们要搞一个outer函数一个inner函数这么复杂呢？一层函数不行吗？

# 　答：请注意，@outer这句代码在程序执行到这里的时候就会自动执行outer函数内部的代码，
# 如果不封装一下，在业务部门还未进行调用的时候，就执行了些什么，这和初衷有点不符。
# 当然，如果你对这个有需求也不是不行。请看下面的例子，它只有一层函数。







# http://python.jobbole.com/85056/
#装饰器学习
a_string = "This is a global variable"
def foo():
    print(locals())
print(globals())
printStr(foo)
foo()#2

print("【2. 作用域】")
# 内建函数 globals 返回一个包含所有 Python 能识别变量的字典。（为了更清楚的描述，输
# 出时省略了 Python 自动创建的变量。）在注释 #2 处，调用了 foo 函数，在函数中打印局
# 部变量的内容。从中可以看到，函数 foo 有自己单独的、此时为空的命名空间。


print("【3. 变量解析规则】")
# Python 的作用域规则是， 变量的创建总是会创建一个新的局部变量但是变量的访问（包括修改）
# 在局部作用域查找然后是整个外层作用域来寻找匹配。所以如果修改 foo 函数来打印全部变量，
# 结果将是我们希望的那样：

def foo3():
    print(a_string)#1
printStr(foo3)
foo3()
# 在 #1 处，Python 在函数 foo 中搜索局部变量 a_string，但是没有找到，然后继续搜索同名的全局变量。
# 另一方面，如果尝试在函数里给全局变量赋值，结果并不是我们想要的那样：

def foo3_1():
    a_string = "test"  #1
    print(locals())
printStr(foo3_1)
foo3_1()
print(a_string)#2

# 从上面代码可见，全部变量可以被访问（如果是可变类型，甚至可以被修改）但是（默认）
# 不能被赋值。在函数 #1 处，实际上是创建了一个和全局变量相同名字的局部变量，并且
# “覆盖”了全局变量。通过在函数 foo 中打印局部命名空间可以印证这一点，并且发现局部
# 命名空间有了一项数据。在 #2 处的输出可以看到，全局命名空间里变量 a_string 的值
# 并没有改变。

print("【4. 变量生命周期】")
# 值得注意的是，变量不仅是在命名空间中有效，它们也有生命周期。思考下面的代码：

def foo4():
    x=1
printStr(foo4)
foo4()
print("该部分需要解开下一行方法的注释")
# print(x)#1
# 这个问题不仅仅是因为 #1 处的作用域规则（虽然那是导致 NameError 的原因），也与Python
# 和很多其他语言中函数调用的实现有关。没有任何语法可以在该处取得变量 x 的值——它确确实实
# 不存在！函数 foo 的命名空间在每次函数被调用时重新创建，在函数结束时销毁。

print("【5. 函数的实参和形参】")
# Python 允许向函数传递参数。形参名在函数里为局部变量。
def foo5(x):
    print(locals())
printStr(foo5)
foo5(1)
# Python 有一些不同的方法来定义和传递函数参数。想要深入的了解，请参考 Python 文档关于函数的定义。
# 【http://docs.python.org/tutorial/controlflow.html#more-on-defining-functions】
# 来说一个简单版本：函数参数可以是强制的位置参数或者可选的有默认值的关键字参数。

def foo5_1(x, y=0):
    return x-y
printStr(foo5_1)
print(foo5_1(y=1,x=3))
# Python 支持在函数调用时使用关键字实参。
# 上述函数是用一个关键字形参和一个位置形参定义的，但此处使用了两个关键字实参来调用该函数。因为参数都有名称，所以传递参数的顺序没有影响。

# 哇哦！说了这么多看起来可以简单概括为一点：函数的参数可以有名称或位置。也就是说这其中
# 稍许的不同取决于是函数定义还是函数调用。可以对用位置形参定义的函数传递关键字实参，
# 反过来也可行！如果还想进一步了解请查看 Python 文档
# 【http://docs.python.org/tutorial/controlflow.html#more-on-defining-functions】。

print("【6. 内嵌函数】")
# Python 允许创建内嵌函数。即可以在函数内部声明函数，并且所有的作用域和生命周期规则仍然适用。

def outer():
    x =1
    def inner():
        print(x)#1
printStr(outer)
outer()

# 以上代码看起来有些复杂，但它仍是易于理解的。来看 #1 —— Python 搜索局部变量 x
#  失败，然后在属于另一个函数的外层作用域里寻找。变量 x 是函数 outer 的局部变量，
# 但函数 inner 仍然有外层作用域的访问权限（至少有读和修改的权限）。在 #2 处调用函
# 数 inner。值得注意的是，inner 在此处也只是一个变量名，遵循 Python 的变量查找规
# 则——Python 首先在 outer 的作用域查找并找到了局部变量 inner。


print("【7. 函数是 Python 中的一级对象】")
# 在 Python 中有个常识：函数和其他任何东西一样，都是对象。函数包含变量，它并不那么特殊。
print(issubclass(int,object))
def method():
    pass
print(method.__class__)
print("方法的class属性：",issubclass(method.__class__,object))

# 也许你从未考虑过函数可以有属性——但是函数在 Python 中，和其他任何东西一样都是对象。
# （如果对此感觉困惑，稍后你会看到 Python 中的类也是对象，和其他任何东西一样！）也许
# 这有点学术的感觉——在 Python 中函数只是常规的值，就像其他任意类型的值一样。这意味着
# 可以将函数当做实参传递给函数，或者在函数中将函数作为返回值返回。如果你从未想过这样使
# 用，请看下面的可执行代码：

def add(x,y):
    return x+y
def apply(fun,x,y):#1
    return fun(x,y)#2

print(apply(add,2,3))#3

# 这个示例对你来说应该不陌生——add 和 sub 是标准的 Python 函数，
# 都是接受两个值并返回一个计算的值。在 #1 处可以看到变量接收一个
# 就像其他普通变量一样的函数。在 #2 处调用了传递给 apply 的函数
# fun——在 Python 中双括号是调用操作符，调用变量名包含的值。在 #3
#  处展示了在 Python 中把函数作为值传参并没有特别的语法——和其他变
# 量一样，函数名就是变量标签。

# 也许你之前见过这种写法—— Python 使用函数作为实参，常见的操作如：
# 通过传递一个函数给 key 参数，来自定义使用内建函数 sorted。但是，
# 将函数作为值返回会怎样？思考下面代码

def outer():
    def inner():
        print("Inside inner")
    return inner#1
out = outer()#2
print(out)
out()

# 这看起来也许有点怪异。在 #1 处返回一个其实是函数标签的变量 inner。
# 也没有什么特殊语法——函数 outer 返回了并没有被调用的函数 inner。还
# 记得变量的生命周期吗？每次调用函数 outer 的时候，函数 inner 会被重
# 新定义，但是如果函数 ouer 没有返回 inner，当 inner 超出 outer 的
# 作用域，inner 的生命周期将结束。


# 在 #2 处将获得返回值即函数 inner，并赋值给新变量 foo。可以看到如果
# 鉴定 foo，它确实包含函数 inner，通过使用调用操作符（双括号，还记得
# 吗？）来调用它。虽然看起来可能有点怪异，但是目前为止并没有什么很难理
# 解的，对吧？hold 住，因为接下来会更怪异！

print("【8.闭包】")

def outer8():
    x = 1
    def inner():
        print(x)#1
    return inner
foo = outer8()
foo()
# print(foo.func_closure)

# 从上一个示例可以看到，inner 是 outer 返回的一个函数，存储在变量 foo 里然后用
#  foo() 来调用。但是它能运行吗？先来思考一下作用域规则。

# Python 中一切都按作用域规则运行—— x 是函数 outer 中的一个局部变量，当函数
#  inner 在 #1 处打印 x 时，Python 在 inner 中搜索局部变量但是没有找到，然
# 后在外层作用域即函数 outer 中搜索找到了变量 x。

# 但如果从变量的生命周期角度来看应该如何呢？变量 x 对函数 outer 来说是局部变量
# ，即只有当 outer 运行时它才存在。只有当 outer 返回后才能调用 inner，所以依
# 据 Python 运行机制，在调用 inner 时 x 就应该不存在了，那么这里应该有某种运
# 行错误出现。

# 结果并不是如此，返回的 inner 函数正常运行。Python 支持一种名为函数闭包的特
# 性，意味着 在非全局作用域定义的 inner 函数在定义时记得外层命名空间是怎样的。
# inner 函数包含了外层作用域变量，通过查看它的 func_closure 属性可以看出这种
# 函数闭包特性。

# 记住——每次调用函数 outer 时，函数 inner 都会被重新定义。此时 x 的值没有变
# 化，所以返回的每个 inner 函数和其它的 inner 函数运行结果相同，但是如果稍做
# 一点修改呢？

def outer8_1(x):
    def inner():
        print(x)#1
    return inner
foo_1 = outer8_1(1)
foo_2 = outer8_1(2)
foo_1()
foo_2()

# 从这个示例可以看到闭包——函数记住其外层作用域的事实——可以用来构建本质上有一个
# 硬编码参数的自定义函数。虽然没有直接给 inner 函数传参 1 或 2，但构建了能“记
# 住”该打印什么数的 inner 函数自定义版本。

# 闭包是强大的技术——在某些方面来看可能感觉它有点像面向对象技术：outer 作为 inner
#  的构造函数，有一个类似私有变量的 x。闭包的作用不胜枚举——如果你熟悉 Python中
# sorted 函数的参数 key，也许你已经写过 lambda 函数通过第二项而非第一项来排序
# 一些列表。也可以写一个 itemgetter 函数，接收一个用于检索的索引并返回一个函数，
# 然后就能恰当的传递给 key 参数了。

# 但是这么用闭包太没意思了！让我们再次从头开始，写一个装饰器。


print("【9.装饰器】")
# 装饰器其实就是一个以函数作为参数并返回一个替换函数的可执行函数。
# 让我们从简单的开始，直到能写出实用的装饰器。

def outer(some_func):
    def inner():
        print("before some_func")
        ret =some_func()#1
        return ret+1
    return inner
def foo():
    return 1
decorated = outer(foo)#2
print(decorated())


# 请仔细看这个装饰器示例。首先，定义了一个带单个参数 some_func 的名为
# outer 的函数。然后在 outer 内部定义了一个内嵌函数 inner。inner 函
# 数将打印一行字符串然后调用 some_func，并在 #1 处获取其返回值。在每
# 次 outer 被调用时，some_func 的值可能都会不同，但不论 some_func
# 是什么函数，都将调用它。最后，inner 返回 some_func() 的返回值加 1。
# 在 #2 处可以看到，当调用赋值给 decorated 的返回函数时，得到的是一行
# 文本输出和返回值 2，而非期望的调用 foo 的返回值 1。

# 我们可以说变量 decorated 是 foo 的装饰版——即 foo 加上一些东西。事实
# 上，如果写了一个实用的装饰器，可能会想用装饰版来代替 foo，这样就总能得
# 到“附带其他东西”的 foo 版本。用不着学习任何新的语法，通过将包含函数的
# 变量重新赋值就能轻松做到这一点：

print("通过将包含函数的变量重新赋值也能轻松做到这一点")
foo = outer(foo)
print(foo())



